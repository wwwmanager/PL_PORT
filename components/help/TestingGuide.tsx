import React, { useEffect, useState } from 'react';

const guideText = `
# Руководство по тестированию

Этот документ описывает стратегию, инструменты и лучшие практики для тестирования приложения "Путевые листы".

## 1. Философия тестирования

Учитывая архитектуру приложения (полностью клиентское, offline-first, сложная бизнес-логика в браузере), тестирование играет ключевую роль в обеспечении его надежности и корректности.

**Основные цели:**
1.  **Гарантировать корректность бизнес-логики**: Проверять правильность расчетов, переходов статусов, управления бланками и других критических операций.
2.  **Предотвращать регрессии**: Убедиться, что новые изменения не ломают существующий функционал.
3.  **Обеспечить стабильность**: Повысить уверенность в качестве кода при рефакторинге и добавлении новых функций.

## 2. Инструменты и настройка

- **Фреймворк**: [Vitest](https://vitest.dev/) — современный, быстрый и совместимый с Vite фреймворк для тестирования.
- **Среда выполнения**: Тесты выполняются в среде \`node\`, как указано в \`vitest.config.ts\`. Это означает, что в тестах нет доступа к DOM (объектам \`window\`, \`document\` и т.д.), что идеально подходит для тестирования чистой бизнес-логики.

Конфигурация в \`vitest.config.ts\` настроена на поиск файлов, заканчивающихся на \`.test.ts\` или \`.spec.ts\`, по всему проекту.

## 3. Виды тестов

### Модульные тесты (Unit Tests)

Это основной вид тестов в проекте. Они проверяют изолированные части функционала (отдельные функции).

- **Что тестировать**: Функции из \`services/mockApi.ts\`, \`services/auditLog.ts\`, \`services/routeParserService.ts\` и другие утилиты.
- **Принцип**: Каждый тест должен быть независимым. Для этого используется хук \`beforeEach\`, чтобы сбросить состояние \`mockApi\` и моки перед каждым запуском. Зависимости, такие как \`storage.ts\`, мокируются для полной изоляции.

**Пример (из \`services/mockApi.test.ts\`):**

\`\`\`typescript
// services/mockApi.test.ts

// Мокируем зависимости вверху файла
vi.mock('./storage', () => ({
  loadJSON: vi.fn().mockResolvedValue([]),
  saveJSON: vi.fn().mockResolvedValue(undefined),
}));

describe('Blank Management', () => {
  beforeEach(() => {
    // Сбрасываем состояние перед каждым тестом
    resetMockApiState();
    vi.clearAllMocks();
  });

  it('should materialize a batch of blanks', async () => {
    // 1. Arrange (Подготовка)
    await createBlankBatch({ organizationId: 'org-test', series: 'BB', startNumber: 10, endNumber: 15 });
    
    // 2. Act (Действие)
    const result = await materializeBatch('batch-1');

    // 3. Assert (Проверка)
    expect(result.created).toBe(6);
    const blanks = await getBlanks();
    expect(blanks.length).toBe(6);
    expect(blanks[0].status).toBe('available');
  });
});
\`\`\`

Аналогичные тесты существуют для \`services/auditBusiness.test.ts\` (проверка логики бизнес-журнала) и \`services/routeParserService.test.ts\` (проверка парсера файлов отчетов).

### Интеграционные тесты (на уровне сервисов)

Эти тесты проверяют взаимодействие нескольких функций для выполнения полноценного пользовательского сценария. В нашем контексте это не UI-тесты, а тесты, проверяющие сложные цепочки вызовов внутри \`mockApi.ts\`.

- **Что тестировать**: Полный жизненный цикл сущностей (например, создание, проведение и корректировка путевого листа), процессы импорта, выдачи бланков и т.д.
- **Принцип**: Тест имитирует последовательность действий, которые привели бы к конечному результату в интерфейсе, и проверяет итоговое состояние системы.

**Пример (из \`services/mockApi.test.ts\`):**

\`\`\`typescript
// services/mockApi.test.ts

describe('Full Scenario: Waybill Lifecycle', () => {
  it('should correctly handle a waybill from creation to posting', async () => {
    // 1. Создание водителя, ТС, пачки бланков
    // 2. Выдача бланка водителю
    // 3. Создание путевого листа (проверка, что бланк зарезервировался)
    // 4. Проведение путевого листа
    // 5. Проверка, что статус ПЛ изменился, а статус бланка стал 'used'
  });
});
\`\`\`

### E2E (End-to-End) тесты (Перспектива)

На данный момент E2E тесты не настроены. Они требуют запуска браузера и имитации действий пользователя (клики, ввод текста).

- **Что тестировать**: Ключевые пользовательские сценарии от начала до конца. Например: "Пользователь заходит в справочник ТС, нажимает 'Добавить', заполняет форму, сохраняет и видит новую запись в таблице".
- **Инструменты**: Для этого можно будет внедрить фреймворки, такие как **Playwright** или **Cypress**.

## 4. Как писать тесты

1.  **Расположение**: Создавайте тестовые файлы рядом с тестируемыми модулями. Например, для \`services/mockApi.ts\` тест находится в \`services/mockApi.test.ts\`.
2.  **Структура**: Используйте \`describe\` для группировки тестов по функционалу, и \`it\` для описания конкретного проверяемого поведения.
3.  **Изоляция**: Всегда используйте \`beforeEach\` для очистки состояния и моков. Это предотвращает влияние одного теста на другой.
4.  **AAA (Arrange, Act, Assert)**: Структурируйте каждый тест по этому принципу:
    -   **Arrange**: Подготовка данных, настройка моков.
    -   **Act**: Вызов тестируемой функции.
    -   **Assert**: Проверка результата с помощью \`expect\`.

## 5. Что тестировать? (Приоритеты)

1.  **Критическая бизнес-логика**: В первую очередь покрывайте тестами самую сложную и важную логику:
    -   \`services/mockApi.ts\`: статусные модели, учет бланков, расчеты.
    -   \`services/auditLog.ts\`, \`services/auditBusiness.ts\`: логика журнала аудита.
    -   \`services/routeParserService.ts\`: логика парсинга файлов.
2.  **"Счастливый путь" (Happy Path)**: Убедитесь, что основной функционал работает, как ожидается, при корректных данных.
3.  **Крайние случаи (Edge Cases)**: Проверяйте поведение системы на невалидных данных:
    -   Неверные переходы статусов.
    -   Попытка выдать уже выданный бланк.
    -   Сохранение формы с пустыми обязательными полями.
    -   Нулевые или отрицательные значения там, где они не допускаются.
4.  **Регрессии**: При исправлении бага напишите тест, который воспроизводит этот баг. Этот тест останется в системе и не позволит ошибке появиться снова.

## 6. Запуск тестов

Для запуска тестов в консоли выполните команду:

\`\`\`bash
npx vitest
\`\`\`

Для запуска в режиме наблюдения (автоматический перезапуск при изменении файлов):

\`\`\`bash
npx vitest watch
\`\`\`
`;

const TestingGuide: React.FC = () => {
    const [markdown, setMarkdown] = useState('');

    useEffect(() => {
        // Basic Markdown to HTML conversion
        const html = guideText
            .replace(/^# (.*$)/gim, '<h1 class="text-3xl font-bold mb-4 mt-6">$1</h1>')
            .replace(/^## (.*$)/gim, '<h2 class="text-2xl font-bold mb-3 mt-5 border-b pb-2">$1</h2>')
            .replace(/^### (.*$)/gim, '<h3 class="text-xl font-semibold mb-2 mt-4">$1</h3>')
            .replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/gim, '<em>$1</em>')
            .replace(/`([^`]+)`/gim, '<code class="bg-gray-200 dark:bg-gray-700 rounded px-1 py-0.5 text-sm">$1</code>')
            .replace(/^\- (.*$)/gim, '<li class="ml-6">$1</li>')
            .replace(/<\/li>\n<li/gim, '</li><li') // fix spacing
            .replace(/<li>/gim, '<li class="mb-2">')
            .replace(/(<li.*?>[\s\S]*?<\/li>)/gim, '<ul>$1</ul>')
            .replace(/<\/ul>\n<ul>/gim, '')
            .replace(/\n/g, '<br />')
            .replace(/<br \/><br \/>/g, '<p></p>') // Paragraphs
            .replace(/```typescript([\s\S]*?)```/g, '<pre class="bg-gray-100 dark:bg-gray-900 p-4 rounded-lg overflow-x-auto text-sm"><code>$1</code></pre>')
            .replace(/```bash([\s\S]*?)```/g, '<pre class="bg-gray-100 dark:bg-gray-900 p-4 rounded-lg overflow-x-auto text-sm"><code>$1</code></pre>');

        setMarkdown(html);
    }, []);

    return (
        <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 md:p-8">
            <div
                className="prose prose-lg dark:prose-invert max-w-none text-gray-700 dark:text-gray-300 space-y-4"
                dangerouslySetInnerHTML={{ __html: markdown }}
            />
        </div>
    );
};

export default TestingGuide;